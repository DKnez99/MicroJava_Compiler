package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    //redefined methods for error reporting (changed error message)
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error!", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal syntax error! Parsing stopped!", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* =========================================================================== */
/* =========================================================================== */
/* =========================================================================== */
/* terminals */

terminal PROG, CONST, EXTENDS, IF, ELSE, DO, WHILE, BREAK, CONTINUE, RETURN, READ, PRINT,  NEW, VOID, CLASS, THIS, ENUM, SUPER;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN;
terminal SEMI, COMMA, COLON, DOT;
terminal ASSIGN;
terminal IS_EQUAL, NOT_EQUAL, GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL;
terminal INC, DEC;
terminal PLUS, MINUS, MUL, DIV, MOD, QQ; 
terminal OR, AND;
terminal String IDENT;
terminal Integer NUMBER_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

/* =========================================================================== */
/* nonterminals */

nonterminal Program, ProgramName, ProgramDeclListNullable, ProgramDecl;
nonterminal ConstDecl, ConstType, ConstAssignList, ConstAssign, ConstName;
nonterminal VarDecl, VarType, VarList, Var, VarName, VarDeclListNullable;
nonterminal ClassDecl, ClassName, ClassExtendsOptional, ClassBody, ClassParentType, ClassBodyMethodsOptional;
nonterminal MethodDecl, MethodReturnType, MethodName, MethodDeclListNullable;
nonterminal FormPars, FormPar, FormParType, FormParName, FormParsOptional;
nonterminal Type;
nonterminal Statement, StatementLabelOptional, StatementListNullable;
nonterminal SingleStatement, SingleStatementElseOptional, SingleStatementPrintNumConstOptional;
nonterminal Statements;
nonterminal DesignatorStatement;
nonterminal ActPars, ActParsOptional;
nonterminal Condition;
nonterminal CondTerm;
nonterminal CondFact;
nonterminal Expr, ExprOptional, RelopExprOptional, NegativeExprOptional, ExprInBracketsOptional;
nonterminal Term, AddopTermListNullable;
nonterminal Factor, FactorType, MulopFactorListNullable, FactorDesignatorParenOptional;
nonterminal Designator;
nonterminal Label;
nonterminal Assignop, Relop, Addop, Mulop;
nonterminal Constant;
nonterminal BracketsOptional;

/* =========================================================================== */
/* precedences */

precedence left ELSE;

/* =========================================================================== */
/* Program */

Program ::= (Program) PROG ProgramName ProgramDeclListNullable LBRACE MethodDeclListNullable RBRACE;

ProgramName ::= (ProgramName) IDENT:programName;

ProgramDeclListNullable ::=
					(ProgramDeclList) ProgramDeclListNullable ProgramDecl
				|
					(EmptyProgramDeclList) /* epsilon */
				;
				
ProgramDecl ::=
					(ProgramDeclConst) ConstDecl
				|
					(ProgramDeclVar) VarDecl
				|
					(ProgramDeclClass) ClassDecl
				;
				
/* =========================================================================== */
/* ConstDecl */

ConstDecl ::= (ConstDecl) CONST ConstType ConstAssignList SEMI;

ConstType ::= (ConstType) Type:constType;

ConstAssignList ::=
					(ConstListSingle) ConstAssign
				|
					(ConstListMany) ConstAssignList COMMA ConstAssign
				;

ConstAssign ::= (ConstAssign) ConstName ASSIGN Constant;

ConstName ::= (ConstName) IDENT:constName;

/* =========================================================================== */
/* VarDecl */

VarDecl ::= (VarDecl) VarType VarList SEMI;

VarType ::= (VarType) Type:varType;

VarList ::=
				(VarListSingle) Var
			|
				(VarListMany) VarList COMMA Var
			;	
				
Var ::=
			(Var) VarName BracketsOptional
		|		
			(VarError) error:l
			{: parser.report_error("Error recovery (level A) in variable declaration at line "+lleft+". Recovered to the next , or ;", null); :}
		;
		
VarName ::= (VarName) IDENT:varName;

VarDeclListNullable ::=
					(VarDeclList) VarDeclListNullable VarDecl
				|
					(EmptyVarDeclListNullable) /* epsilon */
				;

/* =========================================================================== */
/* ClassDecl */

ClassDecl ::= (ClassDecl) CLASS ClassName ClassExtendsOptional LBRACE ClassBody RBRACE;

ClassName ::= (ClassName) IDENT:className;

ClassExtendsOptional ::= 
							(ClassExtendsYes) EXTENDS ClassParentType
						|
							(ClassExtendsNo) /* epsilon */
						;

ClassParentType ::= (ClassParentType) Type:classParentType;

ClassBody ::= (ClassBody) VarDeclListNullable ClassBodyMethodsOptional;

ClassBodyMethodsOptional ::=
								(ClassBodyMethodsYes) LBRACE MethodDeclListNullable RBRACE
							|
								(ClassBodyMethodsNo) /* epsilon */
							;
							
/* =========================================================================== */
/* MethodDecl */
			
MethodDecl ::= (MethodDecl) MethodReturnType MethodName LPAREN FormParsOptional RPAREN VarDeclListNullable LBRACE StatementListNullable RBRACE;

MethodReturnType ::=
						(MethodReturnTypeRegular) Type:methodReturnType
					|
						(MethodReturnTypeVoid) VOID
					;
					
MethodName ::= (MethodName) IDENT:methodName;

MethodDeclListNullable ::=
							(MethodDeclList) MethodDeclListNullable MethodDecl
						|
							(EmptyMethodDeclList) /* epsilon */
						;			
							
/* =========================================================================== */
/* FormPars */	

FormPars ::=
				(FormParsSingle) FormPar
			|
				(FormParsMany) FormPars COMMA FormPar
			; 

FormPar ::=
				(FormPar) FormParType FormParName BracketsOptional
			|
				(FormParError) error:l
				{: parser.report_error("Error recovery (level B) in formal parameters at line "+lleft+". Recovered to the next , or )", null); :}
			;
			
FormParType ::= (FormParType) Type:formParType;

FormParName ::= (FormParName) IDENT:formParName;

FormParsOptional ::= 
					(FormParsYes) FormPars
				|
					(FormParsNo) /* epsilon */
				;
				
/* =========================================================================== */
/* Type */

Type ::= (Type) IDENT:typeName;

/* =========================================================================== */
/* Statement */

Statement ::=
				(StatementSingle) StatementLabelOptional SingleStatement
			|
				(StatementMany) Statements
			;

StatementLabelOptional ::=
							(StatementLabelYes) Label COLON
						|
							(StatementLabelNo) /* epsilon */
						;
						
StatementListNullable ::=
							(StatementList) StatementListNullable Statement
						|
							(EmptyStatementList) /* epsilon */
						;

/* =========================================================================== */
/* SingleStatement */

SingleStatement ::=
					(SingleStatementDesignatorStatement) DesignatorStatement SEMI
				|
					(SingleStatementIf) IF LPAREN Condition RPAREN Statement SingleStatementElseOptional
				|
					(SingleStatementDo) DO Statement WHILE LPAREN Condition RPAREN SEMI
				|
					(SingleStatementBreak) BREAK SEMI
				|
					(SingleStatementContinue) CONTINUE SEMI
				|
					(SingleStatementReturn) RETURN ExprOptional SEMI
				|
					(SingleStatementRead) READ LPAREN Designator RPAREN SEMI
				|
					(SingleStatementPrint) PRINT LPAREN Expr SingleStatementPrintNumConstOptional RPAREN SEMI
				;
				
SingleStatementElseOptional ::=
								(SingleStatementElseYes) ELSE Statement
							|
								(SingleStatementElseNo) /* epsilon */
							;

SingleStatementPrintNumConstOptional ::=
											(SingleStatementPrintNumConstYes) COMMA NUMBER_CONST:printNumber
										|
											(SingleStatementPrintNumConstNo) /* epsilon */
										;

/* =========================================================================== */
/* Statements */

Statements ::= (Statements) LBRACE StatementListNullable RBRACE;

/* =========================================================================== */
/* DesignatorStatement */

DesignatorStatement ::=
							(DesignatorStatementAssign) Designator:desination ASSIGN Expr:expr SEMI
						|
							(DesignatorStatementAssignError) error:l SEMI
							{: parser.report_error("Error recovery (level A) in designator assignment at line "+lleft+". Recovered to the next ;", null); :}
						|
							(DesignatorStatementFunctionCall) Designator:functionName LPAREN ActParsOptional RPAREN SEMI
						|
							(DesignatorStatementPostInc) Designator:varName INC SEMI
						|
							(DesignatorStatementPostDec) Designator:varName DEC SEMI
						;
						
/* =========================================================================== */
/* ActPars */

ActPars ::= 
			(ActParsSingle) Expr
		|
			(ActParsMany) ActPars COMMA Expr
		;

ActParsOptional ::= 
						(ActParsYes) ActPars
					|
						(ActParsNo)	/* epsilon */
					;

/* =========================================================================== */
/* Condition */

Condition ::=
				(ConditionSingle) CondTerm
			|
				(ConditionMany) Condition OR CondTerm
			|
				(ConditionError) Condition error:l
				{: parser.report_error("Error recovery (level B) in condition at line " + lleft + ". Recovered to the next )", null); :}
			;

/* =========================================================================== */
/* CondTerm */

CondTerm ::=
				(CondTermSingle) CondFact
			|
				(CondTermMany) CondTerm AND CondFact
			;

/* =========================================================================== */
/* CondFact */

CondFact ::= (CondFact) Expr RelopExprOptional;

/* =========================================================================== */
/* Expr */

Expr ::=
			(ExprTerm) NegativeExprOptional Term AddopTermListNullable
		;
		
NegativeExprOptional ::=
							(NegativeExprYes) MINUS
						|
							(NegativeExprNo) /* epsilon */
						;
ExprOptional ::=
					(ExprYes) Expr
				|
					(ExprNo) /* epsilon */
				;

ExprInBracketsOptional ::=
							(ExprInBracketsYes) LBRACKET Expr RBRACKET
						|
							(ExprInBracketsNo) /* epsilon */
						;

RelopExprOptional ::=
						(RelopExprYes) Relop Expr
					|
						(RelopExprNo) /* epsilon */
					;

/* =========================================================================== */
/* Term */

Term ::= (Term) Factor MulopFactorListNullable;

/* =========================================================================== */
/* Factor */

Factor ::=
				(FactorDesignator) Designator FactorDesignatorParenOptional
			|
				(FactorConstant) Constant
			|
				(FactorNewType) NEW Type:objectType ExprInBracketsOptional
			|
				(FactorExpr) LPAREN Expr RPAREN	
			;
			
FactorDesignatorParenOptional ::=
									(FactorDesignatorParenYes) LPAREN ActParsOptional RPAREN
								|
									(FactorDesignatorParenNo) /* epsilon */
								;

MulopFactorListNullable ::=
								(MulopFactorList) MulopFactorListNullable Mulop Factor
							|
								(EmptyMulopFactorList) /* epsilon */
							;		

/* =========================================================================== */
/* Designator */
			
Designator ::=	
					(DesignatorClassEntity) Designator:designatorEntityName DOT IDENT:classField
				|
					(DesignatorArray) Designator:designatorArrayName LBRACKET Expr:arrayIndex RBRACKET
				|
					(DesignatorDefault) IDENT:designatorName
				; 

/* =========================================================================== */
/* Label */
			


/* =========================================================================== */
/* Assignop */

Assignop ::= (Assign) ASSIGN;

/* =========================================================================== */
/* Relop */

Relop ::= 
			(IsEqual) IS_EQUAL
		|
			(NotEqual) NOT_EQUAL
		|
			(GreaterThan) GREATER
		|
			(GreaterOrEqualTo) GREATER_OR_EQUAL
		|
			(LessThan) LESS
		|
			(LessOrEqualTo) LESS_OR_EQUAL
		;

/* =========================================================================== */
/* Addop */

Addop ::=
			(Plus) PLUS
		|
			(Minus) MINUS
		;

/* =========================================================================== */
/* Mulop */

Mulop ::= 
			(Mul) MUL
		|
			(Div) DIV
		|
			(Mod) MOD
		;

/* =========================================================================== */
/* Constant */

Constant ::=
				(NumConst) NUMBER_CONST:numberValue
			|
				(CharConst) CHAR_CONST:charValue
			|
				(BoolConst) BOOL_CONST:boolValue
			;

/* =========================================================================== */
/* BracketsOptional */
				
BracketsOptional ::=
						(BracketsYes) LBRACKET RBRACKET
					|
						(BracketsNo) /* epsilon */
					;		
		
/* =========================================================================== */